import Gio from '@gjsify/types/Gio-2.0';
import GLib from '@gjsify/types/GLib-2.0';
import { warnNotImplemented } from '@gjsify/utils';
import { join } from 'path';
import { getEncodingFromOptions, encodeUint8Array, decode } from './encoding.js';
import { readdirSync, writeFileSync, mkdirSync, rmdirSync, unlinkSync } from './sync.js';
import { FileHandle } from './file-handle.js';
import { tempDirPath } from './utils.js';
import { Dirent } from './dirent.js';

import type { 
  OpenFlags,
  ReadOptions,
} from './types/index.js';
import type {
  PathLike,
  Mode,
  RmOptions,
  ObjectEncodingOptions,
  BufferEncodingOption,
  MakeDirectoryOptions,
  RmDirOptions
} from 'fs';

/**
 * Asynchronously creates a directory.
 *
 * The optional `options` argument can be an integer specifying `mode` (permission
 * and sticky bits), or an object with a `mode` property and a `recursive`property indicating whether parent directories should be created. Calling`fsPromises.mkdir()` when `path` is a directory
 * that exists results in a
 * rejection only when `recursive` is false.
 * @since v10.0.0
 * @return Upon success, fulfills with `undefined` if `recursive` is `false`, or the first directory path created if `recursive` is `true`.
 */
async function mkdir(
  path: PathLike,
  options: MakeDirectoryOptions & {
    recursive: true;
  }
): Promise<string | undefined>;
/**
 * Asynchronous mkdir(2) - create a directory.
 * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
 * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
 */
async function mkdir(
  path: PathLike,
  options?:
      | Mode
      | (MakeDirectoryOptions & {
            recursive?: false | undefined;
        })
      | null
): Promise<void>;
/**
 * Asynchronous mkdir(2) - create a directory.
 * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
 * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
 * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
 */
async function mkdir(path: PathLike, options?: Mode | MakeDirectoryOptions | null): Promise<string | undefined> 

async function mkdir(path: PathLike, options?: Mode | MakeDirectoryOptions | null): Promise<string | undefined | void> {

  let recursive: boolean | undefined;
  let mode: Mode | undefined = 0o777;

  if (typeof options === 'object') {
    if(options.recursive) recursive = options.recursive;
    if(options.mode) mode = options.mode
  } else {
    mode = options;
  }

  // TODO async
  const firstPath = mkdirSync(path, {
    recursive,
    mode
  });
  return firstPath;
}

async function readdir(path: string) {
  // TODO async
  return readdirSync(path);
}

async function readFile(path: PathLike | FileHandle, options: ReadOptions = { encoding: null, flag: 'r' }) {
  const file = Gio.File.new_for_path(path.toString());

  const [ok, data] = await new Promise<[boolean, Uint8Array, string]>((resolve, reject) => {
    file.load_contents_async(null, (self, res) => {
      try {
        resolve(file.load_contents_finish(res));
      } catch (error) {
        reject(error);
      }
    });
  });

  if (!ok) {
    // TODO: throw a better error
    throw new Error('failed to read file');
  }

  return encodeUint8Array(getEncodingFromOptions(options, 'buffer'), data);
}

/**
 * Creates a unique temporary directory. A unique directory name is generated by
 * appending six random characters to the end of the provided `prefix`. Due to
 * platform inconsistencies, avoid trailing `X` characters in `prefix`. Some
 * platforms, notably the BSDs, can return more than six random characters, and
 * replace trailing `X` characters in `prefix` with random characters.
 *
 * The optional `options` argument can be a string specifying an encoding, or an
 * object with an `encoding` property specifying the character encoding to use.
 *
 * ```js
 * import { mkdtemp } from 'fs/promises';
 *
 * try {
 *   await mkdtemp(path.join(os.tmpdir(), 'foo-'));
 * } catch (err) {
 *   console.error(err);
 * }
 * ```
 *
 * The `fsPromises.mkdtemp()` method will append the six randomly selected
 * characters directly to the `prefix` string. For instance, given a directory`/tmp`, if the intention is to create a temporary directory _within_`/tmp`, the`prefix` must end with a trailing
 * platform-specific path separator
 * (`require('path').sep`).
 * @since v10.0.0
 * @return Fulfills with a string containing the filesystem path of the newly created temporary directory.
 */
 async function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;
/**
 * Asynchronously creates a unique temporary directory.
 * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
 * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 */
async function mkdtemp(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
/**
 * Asynchronously creates a unique temporary directory.
 * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
 * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
 */
async function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string | Buffer>;

async function mkdtemp(prefix: string, options?: BufferEncodingOption | ObjectEncodingOptions | BufferEncoding | null): Promise<string | Buffer> {
  const encoding: string | undefined = getEncodingFromOptions(options);
  const path = tempDirPath(prefix);

  await mkdir(
    path,
    { recursive: false, mode: 0o700 }
  )

  return decode(path, encoding);
}

async function writeFile(path: string, data: any) {
  // TODO async
  return writeFileSync(path, data);
}

/**
 * Removes the directory identified by `path`.
 *
 * Using `fsPromises.rmdir()` on a file (not a directory) results in the
 * promise being rejected with an `ENOENT` error on Windows and an `ENOTDIR`error on POSIX.
 *
 * To get a behavior similar to the `rm -rf` Unix command, use `fsPromises.rm()` with options `{ recursive: true, force: true }`.
 * @since v10.0.0
 * @return Fulfills with `undefined` upon success.
 */
async function rmdir(path: PathLike, options?: RmDirOptions): Promise<void> {
  // TODO async
  return rmdirSync(path, options);
}

async function unlink(path: string) {
  // TODO async
  return unlinkSync(path);
}

async function open(path: PathLike, flags?: OpenFlags, mode?: Mode): Promise<FileHandle> {
  return new FileHandle({
    path,
    flags,
    mode,
  });
}

async function write<TBuffer extends Uint8Array>(
  fd: number,
  buffer: TBuffer,
  offset?: number | null,
  length?: number | null,
  position?: number | null
): Promise<{
  bytesWritten: number;
  buffer: TBuffer;
}>

async function write(
  fd: number,
  data: string,
  position?: number | null,
  encoding?: BufferEncoding | null
): Promise<{
  bytesWritten: number;
  buffer: string;
}>

async function write<TBuffer extends Uint8Array>(
  fd: number,
  data: string | TBuffer,
  positionOrOffset?: number | null,
  encodingOrLength?: BufferEncoding | null | number,
  position?: number | null
): Promise<{
  bytesWritten: number;
  buffer: string;
}> {
  if(typeof data === 'string') {
    return _writeStr(fd, data, positionOrOffset, encodingOrLength as BufferEncoding | null);
  }
  return _writeBuf<any>(fd, data, positionOrOffset as number | null, encodingOrLength as  null | number, position);
}

async function _writeBuf<TBuffer extends Uint8Array>(
  fd: number,
  buffer: TBuffer,
  offset?: number | null,
  length?: number | null,
  position?: number | null
): Promise<{
  bytesWritten: number;
  buffer: TBuffer;
}> {
  warnNotImplemented("fs.promises.write");
  return {
    bytesWritten: 0,
    buffer
  }
}

async function _writeStr(
  fd: number,
  data: string,
  position?: number | null,
  encoding?: BufferEncoding | null
): Promise<{
  bytesWritten: number;
  buffer: string;
}> {
  warnNotImplemented("fs.promises.write");
  return {
    bytesWritten: 0,
    buffer: data,
  }
}

/**
 * Removes files and directories (modeled on the standard POSIX `rm` utility).
 * @since v14.14.0
 * @return Fulfills with `undefined` upon success.
 */
async function rm(path: PathLike, options?: RmOptions): Promise<void> {
  const file = Gio.File.new_for_path(path.toString());

  const recursive = options?.recursive || false;

  const dirent = new Dirent(path.toString());

  if (dirent.isDirectory()) {
    const childFiles = readdirSync(path, { withFileTypes: true });

    if (!recursive && childFiles.length) {
      throw new Error('Dir is not empty!');
    }
  
    for (const childFile of childFiles) {
      if (childFile.isDirectory()) {
        await rmdir(join(path.toString(), childFile.name), options);
      } else if (childFile.isFile()) {
        await rm(join(path.toString(), childFile.name), options);
      }
    }
  }

  const ok = await new Promise<boolean>((resolve, reject) => {
    try {
      file.delete_async(GLib.PRIORITY_DEFAULT, null, (self, res) => {
        try {
          resolve(file.delete_finish(res));
        } catch (error) {
          reject(error);
        }
      });
    } catch (error) {
      reject(error);
    }

  });

  if (!ok) {
    // TODO: throw a better error
    const err = new Error('failed to remove file ' + path);
    throw err;
  }
}

export {
  readFile,
  mkdir,
  mkdtemp,
  readdir,
  writeFile,
  rmdir,
  unlink,
  open,
  write,
  rm,
};

export default {
  readFile,
  mkdir,
  mkdtemp,
  readdir,
  writeFile,
  rmdir,
  unlink,
  open,
  write,
  rm,
};