{
  "version": 3,
  "sources": ["../../gjs/unit/src/index.ts", "src/test.ts"],
  "sourcesContent": ["import type GLib from '@gjsify/types/GLib-2.0';\nimport { versions } from 'process';\n\nconst mainloop: GLib.MainLoop | undefined = (globalThis as any)?.imports?.mainloop;\n\n// This file is part of the gjsunit framework\n// Please visit https://github.com/philipphoffmann/gjsunit for more information\n\nvar countTestsOverall = 0;\nvar countTestsFailed = 0;\n\nexport interface Namespaces {\n\t[key: string]: () => (void | Promise<void>) | Namespaces;\n}\n\n// Makes this work on Gjs and Node.js\nexport const print = globalThis.print || console.log;\n\nclass MatcherFactory {\n\n\tpublic not?: MatcherFactory;\n\n\tconstructor(protected readonly actualValue: any, protected readonly positive: boolean, withOpposite = true) {\n\t\tif (withOpposite) {\n\t\t\tthis.not = new MatcherFactory(actualValue, !positive, false);\n\t\t}\n\t}\n\n\ttriggerResult(success: boolean, msg: string) {\n\t\tif( (success && !this.positive) ||\n\t\t\t(!success && this.positive) ) {\n\t\t\t++countTestsFailed;\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n\n\tto(callback: (actualValue: any) => boolean) {\n\t\tthis.triggerResult(callback(this.actualValue),\n\t\t\t'      Expected callback to validate'\n\t\t);\n\t}\n\n\ttoBe(expectedValue: any) {\n\t\tthis.triggerResult(this.actualValue === expectedValue,\n\t\t\t'      Expected values to match using ===\\n' +\n\t\t\t'      Expected: ' + expectedValue + '\\n' +\n\t\t\t'      Actual: ' + this.actualValue\n\t\t);\n\t}\n\n\ttoEqual(expectedValue: any) {\n\t\tthis.triggerResult(this.actualValue == expectedValue,\n\t\t\t'      Expected values to match using ==\\n' +\n\t\t\t'      Expected: ' + expectedValue + '\\n' +\n\t\t\t'      Actual: ' + this.actualValue\n\t\t);\n\t}\n\n\ttoMatch(expectedValue: any) {\n\t\tif(typeof this.actualValue.match !== 'function') {\n\t\t\tthrow new Error(`You can not use toMatch on type ${typeof this.actualValue}`);\n\t\t}\n\t\tthis.triggerResult(!!this.actualValue.match(expectedValue),\n\t\t\t'      Expected values to match using regular expression\\n' +\n\t\t\t'      Expression: ' + expectedValue + '\\n' +\n\t\t\t'      Actual: ' + this.actualValue\n\t\t);\n\t}\n\n\ttoBeDefined() {\n\t\tthis.triggerResult(typeof this.actualValue !== 'undefined',\n\t\t\t'      Expected value to be defined'\n\t\t);\n\t}\n\n\ttoBeUndefined() {\n\t\tthis.triggerResult(typeof this.actualValue === 'undefined',\n\t\t\t'      Expected value to be undefined'\n\t\t);\n\t}\n\n\ttoBeNull() {\n\t\tthis.triggerResult(this.actualValue === null,\n\t\t\t'      Expected value to be null'\n\t\t);\n\t}\n\n\ttoBeTruthy() {\n\t\tthis.triggerResult(this.actualValue as unknown as boolean,\n\t\t\t'      Expected value to be truthy'\n\t\t);\n\t}\n\n\ttoBeFalsy() {\n\t\tthis.triggerResult(!this.actualValue,\n\t\t\t'      Expected value to be falsy'\n\t\t);\n\t}\n\n\ttoContain(needle: any) {\n\t\tthis.triggerResult(this.actualValue instanceof Array && this.actualValue.indexOf(needle) !== -1,\n\t\t\t'      Expected ' + this.actualValue + ' to contain ' + needle\n\t\t);\n\t}\n\ttoBeLessThan(greaterValue: number) {\n\t\tthis.triggerResult(this.actualValue < greaterValue,\n\t\t\t'      Expected ' + this.actualValue + ' to be less than ' + greaterValue\n\t\t);\n\t}\n\ttoBeGreaterThan(smallerValue: number) {\n\t\tthis.triggerResult(this.actualValue > smallerValue,\n\t\t\t'      Expected ' + this.actualValue + ' to be greater than ' + smallerValue\n\t\t);\n\t}\n\ttoBeCloseTo(expectedValue: number, precision: number) {\n\t\tvar shiftHelper = Math.pow(10, precision);\n\t\tthis.triggerResult(Math.round((this.actualValue as unknown as number) * shiftHelper) / shiftHelper === Math.round(expectedValue * shiftHelper) / shiftHelper,\n\t\t\t'      Expected ' + this.actualValue + ' with precision ' + precision + ' to be close to ' + expectedValue\n\t\t);\n\t}\n\ttoThrow() {\n\t\tlet errorMessage = ''; \n\t\tvar didThrow = false;\n\t\ttry {\n\t\t\tthis.actualValue();\n\t\t\tdidThrow = false;\n\t\t}\n\t\tcatch(e) {\n\t\t\terrorMessage = e.message || '';\n\t\t\tdidThrow = true;\n\t\t}\n\t\tconst functionName = this.actualValue.name || typeof this.actualValue === 'function' ? \"[anonymous function]\" : this.actualValue.toString();\n\t\tthis.triggerResult(didThrow,\n\t\t\t`      Expected ${functionName} to ${this.positive ? 'throw' : 'not throw'} an exception ${!this.positive && errorMessage ? `, but an error with the message \"${errorMessage}\" was thrown` : ''}`\n\t\t);\n\t}\n}\n\nexport const describe = async function(moduleName: string, callback: () => void | Promise<void>) {\n\tprint('\\n' + moduleName);\n\tawait callback();\n};\n\nexport const it = async function(expectation: string, callback: () => void | Promise<void>) {\n\ttry {\n\t\tawait callback();\n\t\tprint('  \\x1B[32m\u2714\\x1B[39m \\x1B[90m' + expectation + '\\x1B[39m');\n\t}\n\tcatch(e) {\n\t\tprint('  \\x1B[31m\u274C\\x1B[39m \\x1B[90m' + expectation + '\\x1B[39m');\n\t\tprint('\\x1B[31m' + e.message + '\\x1B[39m');\n\t\t// if (e.stack) print(e.stack);\n\t}\n}\n\nexport const expect = function(actualValue: any) {\n\t++countTestsOverall;\n\n\tvar expecter = new MatcherFactory(actualValue, true);\n\n\treturn expecter;\n}\n\nconst runTests = async function(namespaces: Namespaces) {\n\t// recursively check the test directory for executable tests\n\tfor( var subNamespace in namespaces ) {\n\t\tconst namespace = namespaces[subNamespace];\n\t\t// execute any test functions\n\t\tif(typeof namespace === 'function' ) {\n\t\t\tawait namespace();\n\t\t}\n\t\t// descend into subfolders and objects\n\t\telse if( typeof namespace === 'object' ) {\n\t\t\tawait runTests(namespace);\n\t\t}\n\t}\n}\n\nconst printResult = () => {\n\tif( countTestsFailed ) {\n\t\t// some tests failed\n\t\tprint('\\n\\x1B[31m\u274C ' + countTestsFailed + ' of ' + countTestsOverall + ' tests failed\\x1B[39m');\n\t}\n\telse {\n\t\t// all tests okay\n\t\tprint('\\n\\x1B[32m\u2714 ' + countTestsOverall + ' completed\\x1B[39m');\n\t}\n}\n\nconst printRuntime = () => {\n\tif (versions.gjs) {\n\t\tprint(`Running on Gjs ${versions.gjs}`);\n\t} else if(versions.node) {\n\t\tprint(`Running on Node.js ${versions.node}`);\n\t} else {\n\t\tprint(`Running on unknown runtime`);\n\t}\n\t\n}\n\nexport const run = function(namespaces: Namespaces) {\n\tprintRuntime();\n\trunTests(namespaces)\n\t.then(() => {\n\t\tprintResult();\n\t\tprint();\n\t\tmainloop?.quit();\n\t})\n\n  // Run the GJS mainloop for async operations\n  mainloop?.run();\n}\n", "\nimport { run } from '@gjsify/unit';\n\nrun({});"],
  "mappings": ";AACA,qBAAyB;AAEzB,IAAM,WAAuC,YAAoB,SAAS;AAK1E,IAAI,oBAAoB;AACxB,IAAI,mBAAmB;AAOhB,IAAM,QAAQ,WAAW,SAAS,QAAQ;AAmJjD,IAAM,WAAW,eAAe,YAAwB;AAEvD,WAAS,gBAAgB,YAAa;AACrC,UAAM,YAAY,WAAW;AAE7B,QAAG,OAAO,cAAc,YAAa;AACpC,YAAM,UAAU;IACjB,WAES,OAAO,cAAc,UAAW;AACxC,YAAM,SAAS,SAAS;IACzB;EACD;AACD;AAEA,IAAM,cAAc,MAAM;AACzB,MAAI,kBAAmB;AAEtB,UAAM,sBAAiB,mBAAmB,SAAS,oBAAoB,uBAAuB;EAC/F,OACK;AAEJ,UAAM,sBAAiB,oBAAoB,oBAAoB;EAChE;AACD;AAEA,IAAM,eAAe,MAAM;AAC1B,MAAI,wBAAS,KAAK;AACjB,UAAM,kBAAkB,wBAAS,KAAK;EACvC,WAAU,wBAAS,MAAM;AACxB,UAAM,sBAAsB,wBAAS,MAAM;EAC5C,OAAO;AACN,UAAM,4BAA4B;EACnC;AAED;AAEO,IAAM,MAAM,SAAS,YAAwB;AACnD,eAAa;AACb,WAAS,UAAU,EAClB,KAAK,MAAM;AACX,gBAAY;AACZ,UAAM;AACN,cAAU,KAAK;EAChB,CAAC;AAGA,YAAU,IAAI;AAChB;;;AChNA,IAAI,CAAC,CAAC;",
  "names": []
}
